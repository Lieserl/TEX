\section{选择题}
\begin{enumerate}
    \item 在N个结点的顺序表中，算法的时间复杂度为 \textbf{\textit{O(1)}} 的操作是 (\textbf{A})
    \begin{choices}
        \item 访问第 \textbf{\textit{i}} 个结点 $(1 \leq i \leq N)$ 和求第 \textbf{\textit{i}} 个结点的直接前驱 $(2 \leq i \leq N)$
        \item 在第 \textbf{\textit{i}} 个结点后插⼊⼀个新结点 $(1 \leq i \leq N)$
        \item 删除第 \textbf{\textit{i}} 个结点 $(1 \leq i \leq N)$
        \item 将 \textbf{\textit{N}} 个结点从⼩到⼤排序
    \end{choices}
    \item 若某表最常⽤的操作是在最后⼀个结点之后插⼊⼀个结点或删除最后⼀个结点。则采⽤哪种存储⽅式最节省运算时间 (\textbf{D})
    \begin{choices}
        \item 单链表
        \item 双链表
        \item 单循环链表
        \item 带头结点的双循环链表
    \end{choices}
    \newpage
    \item 将两个结点数都为N且都从⼩到⼤有序的单向链表合并成⼀个从⼩到⼤有序的单向链表，那么可能的最少⽐较次数是 (\textbf{B})
    \begin{choices}
        \item \textbf{1}
        \item \textbf{N}
        \item \textbf{2N}
        \item \textbf{NlogN}
    \end{choices}
    \item 已知表头元素为 \textbf{\textit{c}} 的单链表在内存中的存储状态如下表，现将 \textbf{\textit{f}} 存放于 \textbf{1014H} 处，并插⼊到单链表中，若 \textbf{\textit{f}} 在逻辑上位于 \textbf{\textit{a}} 和 \textbf{\textit{e}} 之间，则 \textbf{\textit{a}}、 \textbf{\textit{e}} 、\textbf{\textit{f}} 的“链接地址”依次是 (\textbf{D})
    \begin{choices}
        \item \textbf{1010H}, \textbf{1014H}, \textbf{1004H}
        \item \textbf{1010H}, \textbf{1004H}, \textbf{1014H}
        \item \textbf{1014H}, \textbf{1010H}, \textbf{1004H}
        \item \textbf{1014H}, \textbf{1004H}, \textbf{1010H}
    \end{choices}
    \begin{figure*}[htbp]
        \centering
        \includegraphics*[width = 12cm]{section0_1.png}
    \end{figure*}
    
\end{enumerate}