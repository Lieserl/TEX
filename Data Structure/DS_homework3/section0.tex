\section{选择题}
    \begin{enumerate}
        \item 向一个栈顶指针为 \textbf{top} 的链栈中插入一个 \textbf{p} 所指结点时，其操作步骤为( \textbf{C} )
            \begin{choices}
                \item top->next = p;  
                \item p->next = top->next; top->next = p;
                \item p->next = top; top = p; 
                \item p->next = top; top = top->next;  
            \end{choices}
        \item 一个栈的入栈序列是\textbf{a, b, c, d, e}，则栈的不可能的输出序列是( \textbf{C} ) 
            \begin{choices}
                \item e, d, c, b, a
                \item d, e, c, b, a
                \item d, c, e, a, b
                \item a, b, c, d, e
            \end{choices}
        \item 设栈 \textbf{S} 和队列 \textbf{Q} 的初始状态均为空，元素 \textbf{a、b、c、d、e、f、g} 依次进⼊栈 \textbf{S}。若每个元素出栈后⽴即进⼊队列 \textbf{Q}，且 \textbf{7} 个元素出队的顺序是 \textbf{b、d、c、f、e、a、g}，则栈 \textbf{S} 的容量⾄少是( \textbf{C} )
            \begin{choices}
                \item 1
                \item 2
                \item 3
                \item 4
            \end{choices}
        \item 若⽤⼤⼩为 \textbf{6} 的数组来实现循环队列，且当前 \textbf{front} 和 \textbf{rear} 的值分别为 \textbf{0} 和 \textbf{4}。当从队列中删除两个元素，再加⼊两个元素后，\textbf{front} 和 \textbf{rear} 的值分别为多少( \textbf{A} )
            \begin{choices}
                \item 2 和 0
                \item 2 和 2
                \item 2 和 4
                \item 2 和 6
            \end{choices}
        \item 在一个链队列中，若 \textbf{f, r} 分别为队首、队尾指针，则插入 \textbf{p} 所指结点的操作为( \textbf{C} )
            \begin{choices}
                \item f->next = p; f = p;
                \item r->next = p; r = p;
                \item p->next = r; r = p;
                \item p->next = f; f = p;   
            \end{choices}
        \item 用不带头结点的单链表存储队列时，在进行删除运算时( \textbf{D} )
            \begin{choices}
                \item 仅修改头指针
                \item 仅修改尾指针
                \item 头尾指针都要修改
                \item 头、尾指针可能都要修改
            \end{choices}
        \item 关于递归概念描述不正确的是( \textbf{B} )
            \begin{choices}
                \item 递归算法是直接或间接调用自身的算法
                \item 所有递归函数都能用非递归的方式定义。
                \item \textbf{Fibonacci} 数列可用递归定义出来。
                \item 递归算法容易定义，结构清晰，但运行效率较低，一般地，其所耗费的计算时间和存储空间都要比非递归算法多
            \end{choices}
        \item 设串⻓为 \textbf{n}，模式串⻓为 \textbf{m}，则 \textbf{KMP} 算法所需的附加空间为( \textbf{C} )
            \begin{choices}
                \item \textbf{O(n)}
                \item \textbf{O(m + n)}
                \item \textbf{O(m)}
                \item \textbf{O(m * n)}
            \end{choices}
    \end{enumerate}