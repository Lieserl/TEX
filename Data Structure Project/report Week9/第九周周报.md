# 第九周周报

| 组号  |    班级    |  姓名  |    学号    |
| :---: | :--------: | :----: | :--------: |
|  27   | 2022211305 | 胡宇杭 | 2022212408 |
|  27   | 2022211305 |  孟林  | 2022210484 |
|  27   | 2022211305 | 陈炳璇 | 2022211479 |

## 前端

### 概述
在过去的一周中，我们的前端开发团队集中精力对网站的关键功能进行了深入优化，尤其是在提升景点展示的互动性和易用性方面取得了重大进展。这些更新的目的是为了极大地提升用户体验，确保用户在获取和浏览信息时更加便捷和顺畅。

### 详细进展

#### 1. 按热度展示景点
在本周，我们团队完成了一个重要的新功能，即按照热度顺序展示景点的功能。这一功能的背后是一个复杂的算法，该算法根据用户的互动行为，如点赞、评论和页面浏览次数等因素来计算每个景点的热度。此功能的实施使得用户可以快速地识别出哪些景点最受欢迎，从而更有效地进行他们的浏览规划和旅行安排。
![](9001.png)

#### 2. 图片预览功能
我们新增了一个点击图片即可预览的功能，现在用户可以通过简单地点击景点列表中的图片，迅速查看大图预览。这项功能的加入为用户提供了一种更加直观的方式来查看景点的详细视觉内容，极大地增强了用户在浏览时的视觉体验和满意度。
![](9002.png)
![](9003.png)

#### 3. 基于关键字的搜索功能
我们对搜索功能进行了显著增强，现在用户可以通过输入特定的关键字来搜索与这些关键字匹配的景点内容和描述。这些搜索结果会按照景点的热度顺序进行排序展示，确保用户能够立即发现最相关且受欢迎的景点信息。这项改进极大地提升了网站的功能性和用户的搜索效率，使得用户能够更快找到他们需要的信息。

![](9004.png)

#### 4. 下周的工作预告
展望未来，我们计划在继续优化前端功能的同时，特别是提升网站的响应速度和交互设计方面做出更多努力。在接下来的一周中，我们将专注于提升网站的加载速度和优化用户界面的动态交互效果，目标是为用户提供一个更为流畅和引人入胜的使用体验。

### 总结
通过本周的不懈努力，我们在增加新功能和优化现有服务方面取得了显著成果，显著提升了用户界面的功能性和互动性。我们的开发团队将继续致力于提高网站的性能和用户满意度，确保为用户提供一个高效、便捷和愉悦的在线浏览环境。我们期待未来几周内能持续报告更多的正向进展。

## 后端

### 后端上周计划任务完成情况

1. 完成了 B+ 树插入功能和部分删除功能
2. 未完成 B+ 树的遍历和部分删除功能

### 已完成部分

#### Node 类

```cpp
template<typename DataType, class PrimKey>
class Node
{
    friend NodeCursor<DataType, PrimKey>;
    friend BPlusTree<DataType, PrimKey>;
  private:
    NodeType _type;
    Node<DataType, PrimKey>* _parent;
    std::vector<PrimKey> _primKeys;
    uint32_t _numCells;

    // Internal Node
    std::vector<Node<DataType, PrimKey>*> _child;

    // Leaf Node
    std::vector<DataType> _data;
    Node<DataType, PrimKey>* _leftSibling;
    Node<DataType, PrimKey>* _rightSibling;

  public:
    explicit Node(NodeType type) : _type(type)
    {
        _parent = _leftSibling = _rightSibling = nullptr;
        _numCells = 0;
    }

    uint32_t findPosition(const PrimKey& value);
    void insert(DataType data, PrimKey value);
    void insert(const Node<DataType, PrimKey>* node, PrimKey value);
    [[nodiscard]] bool remove(const PrimKey& value);
    [[nodiscard]] bool isFull() const { return _numCells == MAX_ORDER; }
    [[nodiscard]] bool isOrderSatisfied() const { return _numCells >= (MAX_ORDER + 1) >> 1; }
    [[nodiscard]] bool isBorrowedFrom() const { return isOrderSatisfied(); }
    [[nodiscard]] bool isMerge(const Node<DataType, PrimKey>* node);
};
```

Node 类存储一个 B+ 树节点的所有信息，其中成员变量有：
- 公共成员变量：
  - NodeType _type ： B+ 树节点的类型，有内部节点和叶子节点两种
  - Node<DataType, PrimKey>* _parent ： 当前节点的父节点指针
  - std::vector<PrimKey> _primKeys ： 当前节点存储的索引主键信息
  - uint32_t _numCells ： 当前节点存储的单元数量
- 中间节点成员变量：
  - std::vector<Node<DataType, PrimKey>*> _child ： 孩子节点的指针数组
- 叶子结点成员变量：
  - std::vector<DataType> _data ： 存储实际数据，在数据库中存储的是页的偏移量
  - Node<DataType, PrimKey>* _leftSibling ： 叶子结点的左节点
  - Node<DataType, PrimKey>* _rightSibling ：叶子结点的右节点

在节点内部，我们保证插入时元素的有序递增，因此可以通过二分的方法搜索对应主键的位置

```cpp
template<typename DataType, class PrimKey>
uint32_t Node<DataType, PrimKey>::findPosition(const PrimKey& value)
{
    uint32_t minIndex = 0;
    uint32_t maxIndex = _numCells;

    return binarySearch(_primKeys, minIndex, maxIndex, value);
}
```

其中 *binarySearch* 函数定义如下

```cpp
/**
 * Binary search a contain and return the first elem pos which less than or equal to given value
 *
 * @tparam Container a container to be searched
 * @tparam DataType the type of elem of container
 * @return the first elem pos which less than or equal to given value
 */
template<class Container, typename DataType>
uint32_t binarySearch(const Container& container, uint32_t lowerBound,
                      uint32_t upperBound, const DataType value)
{
    while (lowerBound < upperBound) {
        uint32_t midIndex = ((upperBound - lowerBound) >> 1) + lowerBound;
        if (container[midIndex] >= value) {
            upperBound = midIndex;
        } else {
            lowerBound = midIndex + 1;
        }
    }

    return lowerBound;
}
```

binarySearch 函数接受一个容器和查找范围，返回第一个小于等于传入元素的元素的位置，在 findPosition 函数中，我们传入 numCells 作为搜索上界，因为孩子指针的数量比主键的数量多一

```cpp
emplate<typename DataType, class PrimKey>
void Node<DataType, PrimKey>::insert(const DataType data, PrimKey value)
{
    if (isFull() || _type != INTERNAL) {
        return;
    }

    auto position = findPosition(value);

    _primKeys.insert(_primKeys.begin() + position, value);
    _data.insert(_primKeys.begin() + position, data);
    _numCells ++ ;
}

template<typename DataType, class PrimKey>
void Node<DataType, PrimKey>::insert(const Node<DataType, PrimKey>* node, const PrimKey value)
{
    if(isFull() || _type != LEAF) {
        return;
    }

    auto position = findPosition(value);
    _data.insert(_data.begin() + position, value);
    _child.insert(_child.begin() + position + 1, node);

    node->__parent = this;
    _numCells ++;
}
```

两个 insert 函数分别负责叶子结点和内部节点的插入功能，其中，我们调用了上文的 findPosition 函数来获得需要插入的位置

```cpp
template<typename DataType, class PrimKey>
bool Node<DataType, PrimKey>::remove(const PrimKey& value)
{
    auto minIndex = 0;
    auto maxIndex = _numCells;

    auto position = binarySearch(_primKeys, minIndex, maxIndex, value);
    if (position == _numCells || _primKeys[position] != value) {
        return false;
    }
    _primKeys.erase(_primKeys.begin() + position);
    if (_type == LEAF) {
        _data.erase(_child.begin() + position);
    }
    _numCells -- ;

    return true;
}
```

remove 函数同理，调用 findPosition 函数找到需要删除的元素位置，判断该元素是否与需要删除的元素一致，最后返回删除的结果

最后 4 个函数用于判读当前节点是否满足 B+ 树插入删除时的各种条件

#### NodeCursor 类

```cpp
template<typename DataType, class PrimKey>
class NodeCursor
{
    friend Node<DataType, PrimKey>;
    friend BPlusTree<DataType, PrimKey>;
  private:
    Node<DataType, PrimKey>* _node;
    uint32_t _position;
    bool _endFlag;
    bool _startFlag;

  public:
    NodeCursor()
    {
        _node = nullptr;
        _position = -1;
        _endFlag = false;
        _startFlag = false;
    }

    DataType& getCurrentCellData();
    DataType& getCurrentCellPrimKey();
    NodeCursor<DataType, PrimKey>& operator++ ();
    NodeCursor<DataType, PrimKey>& operator-- ();
};
```

NodeCursor 类用于实现定位 B+ 树中某一节点的某一单元，并且提供了 前向、后项遍历的运算符重载方法

```cpp
template<typename DataType, class PrimKey>
NodeCursor<DataType, PrimKey>& NodeCursor<DataType, PrimKey>::operator++ ()
{
    // iterate cell of current node
    _position ++ ;

    if (_position >= _node->_numCells) {
        // if reach the end of node, iterate next node
        _node->_rightSibling == nullptr ? _endFlag = true, _position = _node->_numCells - 1 : _node = _node->_rightSibling, _position = 0;
    }

    return *this;
}

template<typename DataType, class PrimKey>
NodeCursor<DataType, PrimKey>& NodeCursor<DataType, PrimKey>::operator-- ()
{
    // iterate cell of current node
    _position --;

    if (_position + 1 == 0) {
        // if reach the start of node, iterate previous node
        _node->_leftSibling == nullptr ? _startFlag = true, _position = 0 : _node = _node->_leftSibling, _position = _node->_numCells - 1;
    }

    return *this;
}
```

#### BPlusTree 类

```cpp
template<typename DataType, class PrimKey>
class BPlusTree
{
  private:
    uint16_t _id;
    Node<DataType, PrimKey>* _rootNode;
    Node<DataType, PrimKey>* findLeafNode(const PrimKey& value, Node<DataType, PrimKey>* root);
    void adjustAfterInsert(Node<DataType, PrimKey>* node);
    void adjustAfterDelete(Node<DataType, PrimKey>* node);
    void borrowData(Node<DataType, PrimKey>* node, bool direction, const PrimKey newPrimKey);
    NodeCursor<DataType, PrimKey> findCommonAncestor(const Node<DataType, PrimKey>* a, const Node<DataType, PrimKey>* b);

  public:
    BPlusTree(uint16_t id) : _id(id), _rootNode(nullptr) {}
    NodeCursor<DataType, PrimKey> find(const PrimKey& value);
    void insert(DataType data, PrimKey value);
};
```



```cpp
template<typename DataType, class PrimKey>
Node<DataType, PrimKey>* BPlusTree<DataType, PrimKey>::findLeafNode(const PrimKey& value, Node<DataType, PrimKey>* root)
{
    if (root == nullptr) {
        return nullptr;
    } else if (root->_type == LEAF) {
        return root;
    }

    auto position = root->findPosition(value);
    return findLeafNode(value, root->_child[position]);
}
```

findLeafNode 函数会根据传入主键信息找到对应主键的叶子结点所在位置

```cpp
template<typename DataType, class PrimKey>
NodeCursor<DataType, PrimKey> BPlusTree<DataType, PrimKey>::find(const PrimKey& value)
{
    NodeCursor<DataType, PrimKey> cursor;
    auto leafNode = findLeafNode(value, _rootNode);

    if (leafNode == nullptr) {
        return cursor;
    }

    auto position = leafNode->findPosition(value);
    if (position >= leafNode->_numCells || (position == 0 && leafNode->_data[0] != value)) {
        return cursor;
    }

    cursor._node = leafNode;
    cursor._position = position;

    return cursor;
}
```

find 函数调用 findLeafNode 函数，并在叶子节点中调用节点的成员函数 findPosition 找到具体的单元，并存入 NodeCursor 中并返回

接下来的插入函数和部分删除函数有些复杂，这里不做解释，代码如下：

```cpp
template<typename DataType, class PrimKey>
void BPlusTree<DataType, PrimKey>::adjustAfterInsert(Node<DataType, PrimKey>* node)
{
    if (node == nullptr || !node->isFull()) {
        return;
    }

    auto parent = node->_parent;
    auto oldNode = node;
    auto newNodePrimkey = node->_data[(MAX_ORDER + 1) >> 1];

    Node<DataType, PrimKey> newNode = nullptr;
    if (oldNode->_type == LEAF) {
        newNode = new Node<DataType, PrimKey>(LEAF);
        for (int i = (MAX_ORDER + 1) >> 1; i < oldNode->_numCells; i ++ ) {
            newNode.insert(oldNode->_data[i], oldNode->_primKeys[i]);
        }
    } else {
        newNode = new Node<DataType, PrimKey>(INTERNAL);
        newNode._child[0] = oldNode->_child[(MAX_ORDER >> 1) + 1];
        newNode._child[0]->_parent = newNode;
        oldNode->_child[((MAX_ORDER + 1) >> 1) + 1] = nullptr;
        for (int i = ((MAX_ORDER + 1) >> 1) + 1; i < oldNode->_numCells; i ++ ) {
            newNode.insert(oldNode->_child[i + 1], oldNode->_primKeys[i]);
            oldNode->_child[i + 1] = nullptr;
        }
    }

    newNode._rightSibling = oldNode->_rightSibling;
    newNode._leftSibling = oldNode;
    if (oldNode->_rightSibling != nullptr) {
        oldNode->_rightSibling->_leftSibling = newNode;
    }
    oldNode->_rightSibling = newNode;
    oldNode->_numCells = ((MAX_ORDER + 1) >> 1);

    parent->insert(newNode, newNodePrimkey);
    _rootNode = node == _rootNode ? parent : _rootNode;

    adjustAfterInsert(parent);
}

template<typename DataType, class PrimKey>
void BPlusTree<DataType, PrimKey>::insert(const DataType data, const PrimKey value)
{
    if (_rootNode == nullptr) {
        _rootNode = new Node<DataType, PrimKey>(LEAF);
        _rootNode->insert(data, value);
        return;
    }

    auto node = findLeafNode(value, _rootNode);
    node->insert(data, value);
    adjustAfterInsert(node);
}

template<typename DataType, class PrimKey>
NodeCursor<DataType, PrimKey> BPlusTree<DataType, PrimKey>::findCommonAncestor(const Node<DataType, PrimKey>* a,
                                                                               const Node<DataType, PrimKey>* b)
{
    if (a->_parent == b->_parent) {
        NodeCursor<DataType, PrimKey> cursor;
        auto node = a->_parent;
        cursor._node = node;

        auto posA = node->findPosition(a->_data);
        auto posB = node->findPosition(b->_data);

        if (posA == posB) {
            cursor._position = posA;
        } else {
            cursor._position = posA < posB ? posA : posB;
        }

        return cursor;
    }

    return findCommonAncestor(a->_parent, b->_parent);
}

/**
 * Borrow data from the left/right node of current node
 *
 * @param direction 0: left, 1: right
 */
template<typename DataType, class PrimKey>
void BPlusTree<DataType, PrimKey>::borrowData(Node<DataType, PrimKey>* node, const bool direction, const PrimKey newPrimKey)
{
    Node<DataType, PrimKey>* nodeToBorrow;
    uint32_t childPositionToInsert;
    uint32_t childPositionToBorrow;
    uint32_t primKeyPositionToInsert;
    uint32_t primKeyPositionToBorrow;

    switch (direction) {
        case 0:
            nodeToBorrow = node->_leftSibling;
            childPositionToBorrow = nodeToBorrow->_numCells;
            childPositionToInsert = 0;
            primKeyPositionToBorrow = nodeToBorrow->_numCells - 1;
            primKeyPositionToInsert = 0;
            break;
        case 1:
            nodeToBorrow = node->_rightSibling;
            childPositionToBorrow = 0;
            childPositionToInsert = node->_numCells + 1;
            primKeyPositionToBorrow = 0;
            primKeyPositionToInsert = node->_numCells;
    }

    if (node->_type == INTERNAL) {
        node->_child.insert(node->_child.begin() + childPositionToInsert, nodeToBorrow->_data[childPositionToBorrow]);
        node->_primKeys.insert(node->_child.begin() + primKeyPositionToInsert, newPrimKey);
        if (direction) {
            nodeToBorrow->_child[childPositionToBorrow]->_parent = node;
            nodeToBorrow->_child.erase(node->_child.begin() + childPositionToBorrow);
        } else {
            node->_child[childPositionToInsert]->_parent = node;
        }
    } else {
        node->_data.insert(node->_data.begin() + primKeyPositionToInsert,
                           nodeToBorrow->_data[primKeyPositionToBorrow]);
        node->_primKeys.insert(node->_data.begin() + primKeyPositionToInsert,
                               nodeToBorrow->_primKeys[primKeyPositionToBorrow]);
    }
    nodeToBorrow->_numCells -- ;
    node->_numCells ++ ;
}

template<typename DataType, class PrimKey>
void BPlusTree<DataType, PrimKey>::adjustAfterDelete(Node<DataType, PrimKey>* node)
{
    if (node == _rootNode || node->isOrderSatisfied()) {
        return;
    }

    if (node->_leftSibling != nullptr && node->_leftSibling->isBorrowedFrom()) {
        auto value = node->_primKeys[0];
        auto cursor = findCommonAncestor(node->_leftSibling, node);
        auto& commonPrimKey = cursor.getCurrentCellPrimKey();
        borrowData(node, 0, commonPrimKey);
        commonPrimKey = value;
        return;
    } else if (node->_rightSibling != nullptr && node->_rightSibling->isBorrowedFrom()) {
        auto value = node->_rightSibling->_primKeys[0];
        auto cursor = findCommonAncestor(node->_rightSibling, node);
        auto& commonPrimKey = cursor.getCurrentCellPrimKey();
        borrowData(node, 1, commonPrimKey);
        commonPrimKey = value;
        return;
    } else {
        // TODO: handle other situations
    }
}
```

### 下周工作

完成上周没完成的部分，五一快乐！